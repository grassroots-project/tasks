name: Sync Task Status

on:
  issues:
    types: [labeled]

jobs:
  sync-status:
    if: >
      github.event.label.name == 'è¿›è¡Œä¸­' ||
      github.event.label.name == 'å·²å®Œæˆ'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Sync member task status
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const label = context.payload.label.name;
            const taskRef = `#${issue.number} ${issue.title}`;
            const assignees = issue.assignees.map(a => a.login.toLowerCase());

            if (assignees.length === 0) {
              console.log('No assignees, skipping.');
              return;
            }

            // Get current people.md
            const file = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'data/people.md',
              ref: 'main'
            });

            let content = Buffer.from(file.data.content, 'base64').toString('utf8');
            let updated = false;

            // Parse members: find GitHub username -> member block
            const memberBlocks = content.split(/(?=^### )/m).filter(b => b.startsWith('### '));

            for (const assignee of assignees) {
              // Find member block matching this GitHub username
              const blockIndex = memberBlocks.findIndex(block => {
                const ghMatch = block.match(/\*\*GitHub\*\*ï¼š\s*(.+)/);
                return ghMatch && ghMatch[1].trim().toLowerCase() === assignee;
              });

              if (blockIndex === -1) {
                console.log(`Member not found for GitHub user: ${assignee}`);
                continue;
              }

              let block = memberBlocks[blockIndex];

              if (label === 'è¿›è¡Œä¸­') {
                // Add to å½“å‰ä»»åŠ¡
                const currentMatch = block.match(/(\*\*å½“å‰ä»»åŠ¡\*\*ï¼š)(.*)/);
                if (currentMatch) {
                  const current = currentMatch[2].trim();
                  if (current === '-' || current === '') {
                    block = block.replace(currentMatch[0], `${currentMatch[1]}${taskRef}`);
                  } else if (!current.includes(`#${issue.number}`)) {
                    block = block.replace(currentMatch[0], `${currentMatch[1]}${current}ã€${taskRef}`);
                  }
                  memberBlocks[blockIndex] = block;
                  updated = true;
                }
              } else if (label === 'å·²å®Œæˆ') {
                // Remove from å½“å‰ä»»åŠ¡
                const currentMatch = block.match(/(\*\*å½“å‰ä»»åŠ¡\*\*ï¼š)(.*)/);
                if (currentMatch) {
                  let current = currentMatch[2].trim();
                  // Remove this task reference (various formats)
                  current = current.replace(new RegExp(`#${issue.number}\\s*[^ã€]*`), '').replace(/^ã€|ã€$|ã€{2,}/g, '').trim();
                  if (!current) current = '-';
                  block = block.replace(currentMatch[0], `${currentMatch[1]}${current}`);
                }

                // Add to å†å²è´¡çŒ®
                const historyMatch = block.match(/(\*\*å†å²è´¡çŒ®\*\*ï¼š)(.*)/);
                if (historyMatch) {
                  const history = historyMatch[2].trim();
                  if (history === '-' || history === '') {
                    block = block.replace(historyMatch[0], `${historyMatch[1]}${taskRef}`);
                  } else if (!history.includes(`#${issue.number}`)) {
                    block = block.replace(historyMatch[0], `${historyMatch[1]}${history}ã€${taskRef}`);
                  }
                }

                memberBlocks[blockIndex] = block;
                updated = true;
              }
            }

            if (!updated) {
              console.log('No updates needed.');
              return;
            }

            // Rebuild content
            const header = content.split(/(?=^### )/m)[0];
            const afterMembers = content.match(/(---\s*\n## å¦‚ä½•åŠ å…¥[\s\S]*)/);
            const newContent = header + memberBlocks.join('') + (afterMembers ? '\n' + afterMembers[1] : '');

            // Create branch
            const branchName = `sync/task-${issue.number}-${label === 'è¿›è¡Œä¸­' ? 'active' : 'done'}`;
            const mainRef = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main'
            });

            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/heads/${branchName}`,
                sha: mainRef.data.object.sha
              });
            } catch (e) {
              await github.rest.git.updateRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${branchName}`,
                sha: mainRef.data.object.sha,
                force: true
              });
            }

            // Update file
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'data/people.md',
              message: `[åŒæ­¥] ${label === 'è¿›è¡Œä¸­' ? 'é¢†å–' : 'å®Œæˆ'}ä»»åŠ¡ #${issue.number}`,
              content: Buffer.from(newContent).toString('base64'),
              sha: file.data.sha,
              branch: branchName
            });

            // Create PR
            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[åŒæ­¥] ${assignees.join(', ')} ${label === 'è¿›è¡Œä¸­' ? 'é¢†å–' : 'å®Œæˆ'}ä»»åŠ¡ #${issue.number}`,
              head: branchName,
              base: 'main',
              body: `## å˜æ›´ç±»å‹\n- [x] äººæ‰åº“å˜æ›´\n\n## å˜æ›´å†…å®¹\nè‡ªåŠ¨åŒæ­¥ä»»åŠ¡çŠ¶æ€ï¼š**${label}** â†’ æ›´æ–°æˆå‘˜çš„${label === 'è¿›è¡Œä¸­' ? 'å½“å‰ä»»åŠ¡' : 'å†å²è´¡çŒ®'}ã€‚\n\n## å˜æ›´åŸå› \nä»»åŠ¡ #${issue.number} çŠ¶æ€å˜æ›´ä¸ºã€Œ${label}ã€ã€‚\n\n---\n*æ­¤ PR ç”± GitHub Action è‡ªåŠ¨åˆ›å»º*`
            });

            // Comment on issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `ğŸ“‹ äººæ‰åº“åŒæ­¥ PR #${pr.data.number} å·²åˆ›å»ºï¼ˆ${label === 'è¿›è¡Œä¸­' ? 'æ·»åŠ åˆ°å½“å‰ä»»åŠ¡' : 'ç§»è‡³å†å²è´¡çŒ®'}ï¼‰ã€‚`
            });
